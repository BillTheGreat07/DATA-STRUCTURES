![run-tests](../../workflows/run-tests/badge.svg)

## 2024 Project 2

Εκφώνηση: https://k08.chatzi.org/projects/project2/


### Προσωπικά στοιχεία

__Όνομα__: ΒΑΣΙΛΕΙΟΣ ΖΑΧΑΡΙΑΣ

__Α.Μ.__: sdi1900275

### Ασκήσεις που παραδίδονται

Συμπληρώστε `[x]` στις ασκήσεις (και τυχόν bonus) που παραδίδετε.

- [x] Άσκηση 1
- [x] Άσκηση 2
- [x] Άσκηση 3
- [x] Άσκηση 4
- [x] Άσκηση 5
- [x] Bonus 1
- [ ] Bonus 2

### Documentation

Συμπληρώστε εδώ __όσο documentation χρειάζεται__ ώστε οι βαθμολογητές να
κατανοήσουν πλήρως τις λύσεις σας και να τις βαθμολογήσουν ανάλογα. Αυτό θα
πρέπει να γίνει ανεξάρτητα με το αν ο κώδικάς σας είναι καλά σχολιασμένος,
πράγμα που συνιστάται.

#### Άσκηση 1

##### Πολυπλοκότητα Λειτουργιών

* set_from_vector: Η συνάρτηση αυτή έχει πολυπλοκότητα O(n log n), όπου n είναι ο αριθμός των στοιχείων του vector. Κάθε εισαγωγή στο set είναι O(log n) και γίνονται n εισαγωγές.

* set_to_vector: Η συνάρτηση αυτή έχει πολυπλοκότητα O(n), όπου n είναι ο αριθμός των στοιχείων του set. Η διάσχιση του set και η εισαγωγή στο vector είναι O(1) για κάθε στοιχείο.

#### Άσκηση 2

##### Πολυπλοκότητα Λειτουργιών

* set_traverse: O(n), όπου n είναι ο αριθμός των στοιχείων του set.

* set_merge: O(n log n), όπου n είναι το άθροισμα των στοιχείων των δύο sets.

* set_find_k_smallest: O(k), όπου k είναι η θέση του στοιχείου.

#### Άσκηση 3

##### Πολυπλοκότητα Λειτουργιών

* set_traverse: O(n)

* set_to_vector: O(n)

#### Άσκηση 4

##### Πολυπλοκότητα Λειτουργιών

* set_from_vector: O(n) όταν τα στοιχεία είναι ήδη σε σωστή διάταξη, O(n log n) όταν δεν είναι.

* set_merge: O(n1 + n2)

##### Αλγόριθμος δημιουργίας balanced BST από sorted array
1. Βρείτε το μεσαίο στοιχείο του array και κάντε το root του δέντρου.
2. Επαναλάβετε το ίδιο για τα αριστερά και τα δεξιά υπο-arrays για να δημιουργήσετε το αριστερό και το δεξιό υποδέντρο αντίστοιχα.

Αυτό εξασφαλίζει ότι το δέντρο είναι balanced και έχει ύψος log(n).

#### Άσκηση 5

##### Πολυπλοκότητα Λειτουργιών

* set_find_k_smallest: O(h)

##### Λειτουργία set_find_k_smallest

Η συνάρτηση αυτή εκμεταλλεύεται την πληροφορία του μεγέθους των υποδέντρων για να βρει το k-οστό μικρότερο στοιχείο σε O(h) χρόνο, όπου h είναι το ύψος του δέντρου. Κατά την εισαγωγή και διαγραφή στοιχείων, ενημερώνουμε το μέγεθος των υποδέντρων ώστε να μπορούμε να εντοπίσουμε γρήγορα το k-οστό στοιχείο.